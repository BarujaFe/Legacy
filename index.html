<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Copiar R√°pido ‚Äî Gemini & ChatGPT</title>
<style>
  :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--white:#e6eef8}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:16px;background:linear-gradient(180deg,#071127 0%, #071a2a 100%);color:var(--white);}
  .wrap{max-width:980px;margin:0 auto;}
  h1{font-size:20px;margin:6px 0 18px}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:16px}
  .card{background:rgba(255,255,255,0.03);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6);position:relative}
  .card h2{font-size:16px;margin:0 0 8px}
  .links{display:flex;flex-direction:column;gap:6px;margin-bottom:10px}
  .link{display:flex;gap:8px;align-items:center;justify-content:space-between;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
  .url{font-size:13px;color:var(--accent);word-break:break-all;text-decoration:none}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:8px;color:var(--white);cursor:pointer}
  .text-block{background:#031424;border-radius:8px;padding:12px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;white-space:pre-wrap;line-height:1.4;cursor:pointer;color:var(--muted);max-height:520px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
  .hint{font-size:12px;color:var(--muted);margin-top:8px}
  .toast{position:fixed;right:18px;bottom:18px;background:var(--accent);color:#042023;padding:10px 14px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.5);transform:translateY(12px);opacity:0;pointer-events:none;transition:all .28s ease}
  .toast.show{opacity:1;transform:translateY(0);pointer-events:auto}
  .small{font-size:13px;color:var(--muted)}
  .top-actions{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}
  .copy-all{background:linear-gradient(90deg,var(--accent),#7c3aed);border:none;padding:8px 12px;border-radius:10px;color:#021;cursor:pointer}
  footer{margin-top:18px;font-size:13px;color:var(--muted)}
  @media (max-width:420px){h1{font-size:18px}}
</style>
</head>
<body>
<div class="wrap">
  <h1>Ferramenta r√°pida ‚Äî clique no texto pra copiar ao clipboard</h1>

  <div class="top-actions">
    <button class="copy-all btn" id="copyAll">üìã Copiar tudo</button>
    <div class="small">Clique em qualquer bloco de texto ou bot√£o de copiar. Links abrem em nova guia.</div>
  </div>

  <div class="grid">
    <!-- CARD: Gemini -->
    <section class="card" aria-labelledby="g-title">
      <h2 id="g-title">1) Gemini ‚Äî links + instru√ß√£o</h2>

      <div class="links">
        <div class="link">
          <a class="url" href="https://gemini.google.com/app?hl=pt-BR" target="_blank">https://gemini.google.com/app?hl=pt-BR</a>
          <button class="btn" onclick="copyText(event,'https://gemini.google.com/app?hl=pt-BR')">Copiar</button>
        </div>
        <div class="link">
          <a class="url" href="https://www.invertexto.com/localizar-e-substituir" target="_blank">https://www.invertexto.com/localizar-e-substituir</a>
          <button class="btn" onclick="copyText(event,'https://www.invertexto.com/localizar-e-substituir')">Copiar</button>
        </div>
      </div>

      <div class="text-block" tabindex="0" title="Clique para copiar" data-copy>

üí¨ Instru√ß√µes para o Gemini ‚Äì Processamento de Relat√≥rio T√©cnico (1D, 1S, 1M + Avalia√ß√£o de mercado)

Oi Gemini, estou te enviando os PDFs com relat√≥rios t√©cnicos do TradingView para os seguintes ativos:

* Ethereum (ETH)
* Aptos (APT)
* ChainLink (LINK)
* Mercado Livre (MELI34)
* Solana (SOL)
* Apple (AAPL34)
* Alibaba (BABA34)

Al√©m disso, tenho dados recentes do top 65 criptomoedas e do top 100 a√ß√µes por valor de mercado, incluindo:

Criptomoedas:

* Nome, Pre√ßo, 1h %, 24h %, 7d %, Cap. de Mercado, Volume(24h), Fornecimento Circulante, √öltimos 7 Dias

A√ß√µes:

* Pa√≠s/Regi√£o, Valor de Mercado, Pre√ßo, Varia√ß√£o %, Volume Rel., P/L, EPS dil TTM, Crescimento EPS dil. 12M Ano a Ano, Div. Yield %, Setor, Classifica√ß√£o dos Analistas

Preciso que voc√™ fa√ßa o seguinte:

### üîπ 1. Estruture a sa√≠da de forma clara e organizada

Para cada ativo dos PDFs, me entregue um bloco de texto neste formato:

Ativo: \[nome]
Pre√ßo atual: \[se dispon√≠vel no PDF]
Pre√ßo estrat√©gico de compra: \[usar como refer√™ncia]

* ETH ‚Üí US\$ 4.000
* SOL ‚Üí US\$ 165
* LINK ‚Üí US\$ 22
* APT ‚Üí US\$ 4,00
* AAPL34 ‚Üí R\$ 59
* MELI34 ‚Üí R\$ 103
* BABA34 ‚Üí R\$ 22,50‚Äì23,50

Resumo t√©cnico:

* Di√°rio (1D): \[sinal de compra/venda/manter + principais motivos]
* Semanal (1S): \[idem]
* Mensal (1M): \[idem]

Observa√ß√µes: \[anota√ß√µes relevantes, diverg√™ncias entre indicadores, suporte/resist√™ncia]

---

### üîπ 2. Foque no essencial

* Resuma Osciladores, M√©dias M√≥veis e Pontos de Piv√¥ em insights curtos (n√£o copie tabela inteira).
* Destaque contradi√ß√µes relevantes (ex.: tend√™ncia geral de baixa, mas m√©dias m√≥veis fortes em alta).
* Aponte sinais de risco (ex.: sobrecompra, perda de for√ßa no curto prazo).

---

### üîπ 3. Adapte para a estrat√©gia j√° definida

* Use os pre√ßos estrat√©gicos de compra como refer√™ncia.

  * Se o ativo est√° pr√≥ximo ou abaixo do pre√ßo estrat√©gico, marque como ‚Äúüö® oportunidade pr√≥xima‚Äù.
  * Se est√° longe, marque como ‚Äúainda distante do ponto de entrada‚Äù.

* Para os top 65 criptos e top 100 a√ß√µes, avalie:

  * Existe algum ativo com melhor ponto de entrada ou maior potencial de valoriza√ß√£o do que os que j√° monitoramos?
  * Se sim, indique nome, pre√ßo atual, pre√ßo estrat√©gico recomendado e justificativa t√©cnica resumida.
  * Classifique como ‚Äúüö® oportunidade potencial‚Äù ou ‚Äúüìå monitorar‚Äù.

---

### üîπ 4. Entregue em texto corrido e claro

* O objetivo √© eu poder copiar sua resposta e mandar direto para o ChatGPT, para que ele avalie minha situa√ß√£o de investimento.
* Sem introdu√ß√µes longas ou explica√ß√µes gen√©ricas. Apenas an√°lise condensada, padronizada e interpret√°vel, pronta para uso.

---


      </div>
      <p class="hint small">Clique no bloco acima para copiar o texto inteiro.</p>
    </section>

    <!-- CARD: ChatGPT -->
    <section class="card" aria-labelledby="c-title">
      <h2 id="c-title">2) ChatGPT ‚Äî links + mensagem inicial</h2>

      <div class="links">
        <div class="link">
          <a class="url" href="https://chatgpt.com/" target="_blank">https://chatgpt.com/</a>
          <button class="btn" onclick="copyText(event,'https://chatgpt.com/')">Copiar</button>
        </div>
        <div class="link">
          <a class="url" href="https://www.invertexto.com/localizar-e-substituir" target="_blank">https://www.invertexto.com/localizar-e-substituir</a>
          <button class="btn" onclick="copyText(event,'https://www.invertexto.com/localizar-e-substituir')">Copiar</button>
        </div>
      </div>

      <div class="text-block" tabindex="0" title="Clique para copiar" data-copy>

üí¨ Mensagem de in√≠cio de conversa para o ChatGPT

Oi ChatGPT! Vamos dar continuidade √† nossa an√°lise de investimentos. Quero que voc√™ use o contexto da minha estrat√©gia j√° definida e o resumo t√©cnico que o Gemini me entregou (logo abaixo), incluindo tamb√©m a avalia√ß√£o do top 65 criptomoedas e top 100 a√ß√µes, para avaliar minha situa√ß√£o atual e poss√≠veis alternativas melhores.

üìå Minha estrat√©gia base:

* Apple (AAPL34) ‚Üí seguro, comprar abaixo de R\$ 59.
* Ethereum (ETH) ‚Üí seguro, comprar perto de US\$ 4.000.
* Solana (SOL) ‚Üí relativamente seguro, comprar perto de US\$ 165.
* Alibaba (BABA34) ‚Üí relativamente seguro, comprar entre R\$ 22,50‚Äì23,50.
* Chainlink (LINK) ‚Üí alto potencial, comprar perto de US\$ 22.
* Aptos (APT) ‚Üí alto potencial/alto risco, comprar perto de US\$ 4,00.
* Mercado Livre (MELI34) ‚Üí grande potencial, comprar perto de R\$ 103.

üéØ Resumo da estrat√©gia geral:

* Apple + Ethereum ‚Üí pilares de seguran√ßa.
* Solana + Alibaba ‚Üí meio-termo (risco controlado, potencial bom).
* Chainlink + Aptos + MELI ‚Üí alto potencial, risco maior.

‚ö° Sua tarefa com o resumo t√©cnico do Gemini e dados adicionais:

1. Dizer quais ativos j√° est√£o no ponto de compra.
2. Quais est√£o pr√≥ximos do ponto de entrada estrat√©gico.
3. Quais est√£o longe do ponto de entrada.
4. Indicar se algum cen√°rio mudou em rela√ß√£o √† minha estrat√©gia base.
5. Avaliar o top 65 criptos e top 100 a√ß√µes: se h√° ativos com melhor potencial ou ponto de entrada mais interessante que os ativos j√° monitorados.
6. Me dar um parecer pr√°tico: comprar, esperar, ou apenas monitorar.
7. Destacar sinais de risco ou oportunidades excepcionais.

---

üìÑ Resumo t√©cnico (do Gemini + dados de mercado):
abcdef

---

üëâ A partir disso, quero que voc√™ me d√™ uma an√°lise direta, condensada, pr√°tica e alinhada com a estrat√©gia que j√° definimos.

---

      </div>
      <p class="hint small">Clique no bloco acima para copiar o texto inteiro.</p>
    </section>

    <!-- CARD: WebScraping Script -->
    <section class="card" aria-labelledby="w-title">
      <h2 id="w-title">3) WebScraping (Python) ‚Äî script</h2>

      <div class="links">
        <div class="link">
          <div class="url">Script Python (clique no bloco para copiar)</div>
          <button class="btn" onclick="copyText(event, webScriptText)">Copiar</button>
        </div>
      </div>

      <div class="text-block" tabindex="0" title="Clique para copiar" data-copy>
import os
import time
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from fpdf import FPDF
from PIL import Image
from webdriver_manager.chrome import ChromeDriverManager

# --- Pasta de sa√≠da ---
output_folder = os.path.join(os.path.expanduser("~"), "Documents", "CriptoSonho")
os.makedirs(output_folder, exist_ok=True)

# --- Chrome options (gerenciador autom√°tico do chromedriver) ---
chrome_options = Options()
chrome_options.add_argument("--headless=new")
chrome_options.add_argument("--hide-scrollbars")
chrome_options.add_argument("--disable-gpu")
chrome_options.add_argument("--no-sandbox")
# N√£o definir window-size global aqui; vamos ajustar antes de cada captura

driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
wait = WebDriverWait(driver, 15)

# --- Helpers ---
def safe_click(xpath, timeout=10):
    try:
        el = WebDriverWait(driver, timeout).until(EC.presence_of_element_located((By.XPATH, xpath)))
        driver.execute_script("arguments[0].click();", el)
        time.sleep(1.2)
        return True
    except Exception as e:
        print(f"[safe_click] Falha ao clicar em {xpath}: {e}")
        return False

def save_screenshot_and_crop(full_path, out_path, width, height):
    """Abre full_path, corta (0,0,width,height) e salva em out_path."""
    img = Image.open(full_path)
    # Se imagem for menor que crop, ajusta para o tamanho dispon√≠vel
    img_w, img_h = img.size
    crop_w = min(width, img_w)
    crop_h = min(height, img_h)
    cropped = img.crop((0, 0, crop_w, crop_h))
    cropped.save(out_path)

# --- Parte A: PDFs individuais para s√≠mbolos (TradingView) ---
def capture_top_screenshot_for_timeframe(url, timeframe_xpath, filename, crop_width=1888, crop_height=2190):
    """
    Acessa url, clica no timeframe indicado por timeframe_xpath (se fornecido),
    tira screenshot full page e corta top para crop_width x crop_height.
    """
    driver.get(url)
    time.sleep(4)  # aguarda carregar a p√°gina e scripts
    # tenta clicar o timeframe (caso xpath exista)
    if timeframe_xpath:
        try:
            safe_click(timeframe_xpath, timeout=6)
        except Exception:
            pass

    # Ajusta janela para o tamanho total do documento antes de salvar
    scroll_w = driver.execute_script("return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, window.innerWidth);")
    scroll_h = driver.execute_script("return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, window.innerHeight);")
    # limitar height razoavelmente para evitar erros de plataforma; aqui permitimos at√© 10000
    scroll_h = min(scroll_h, 10000)
    driver.set_window_size(scroll_w, scroll_h)
    time.sleep(0.8)
    full_path = os.path.join(output_folder, "full_" + filename)
    driver.save_screenshot(full_path)
    out_path = os.path.join(output_folder, filename)
    save_screenshot_and_crop(full_path, out_path, crop_width, crop_height)
    print(f"[capture_top] Salvo: {out_path}")
    return out_path

def create_pdf_from_images(image_paths, pdf_name):
    pdf_path = os.path.join(output_folder, pdf_name)
    if os.path.exists(pdf_path):
        os.remove(pdf_path)
    pdf = FPDF(unit="pt", format="A4")
    page_w, page_h = pdf.w_pt, pdf.h_pt
    for img_path in image_paths:
        img = Image.open(img_path)
        img_w, img_h = img.size
        ratio = min(page_w / img_w, page_h / img_h)
        new_w, new_h = img_w * ratio, img_h * ratio
        x = (page_w - new_w) / 2
        y = (page_h - new_h) / 2
        pdf.add_page()
        pdf.image(img_path, x, y, new_w, new_h)
    pdf.output(pdf_path)
    print(f"[create_pdf] PDF gerado: {pdf_path}")
    return pdf_path

def generate_tradeview_symbol_pdfs(symbols):
    """
    symbols: lista de tuplas (symbol, url, pdf_name)
    para cada s√≠mbolo gera 3 screenshots: 1D, 1W, 1M (usando xpaths de timeframe)
    """
    # XPaths de timeframe (usados no seu script original)
    xpaths = {
        "1D": '//*[@id="1D"]/span[1]/span',
        "1W": '//*[@id="1W"]/span[1]/span',
        "1M": '//*[@id="1M"]/span[1]/span'
    }

    for symbol, url, pdf_name in symbols:
        print(f"\n[Symbols] Processando {symbol} -> {url}")
        shots = []
        # 1D
        shots.append(capture_top_screenshot_for_timeframe(url, xpaths["1D"], f"{symbol}_1D.png", crop_width=1888, crop_height=2190))
        # 1W
        shots.append(capture_top_screenshot_for_timeframe(url, xpaths["1W"], f"{symbol}_1W.png", crop_width=1888, crop_height=2190))
        # 1M
        shots.append(capture_top_screenshot_for_timeframe(url, xpaths["1M"], f"{symbol}_1M.png", crop_width=1888, crop_height=2190))
        # cria PDF com 3 imagens
        create_pdf_from_images(shots, pdf_name)

# --- Parte B: Capturas full-width 4950px (CoinMarketCap + TradingView Companies) ---
def capture_full_width(url, filename, target_width=4950, max_height=12000):
    """
    Captura a p√°gina inteira definindo a largura target_width e altura baseada no scrollHeight.
    Salva image em output_folder/filename e retorna caminho.
    """
    driver.get(url)
    time.sleep(4)  # aguarda carregamento inicial
    
    # calcula scrollHeight e define janela
    page_w = driver.execute_script("return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, window.innerWidth);")
    page_h = driver.execute_script("return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, window.innerHeight);")
    # queremos for√ßar largura = target_width, e altura = page_h (limitada)
    use_w = max(target_width, page_w)
    use_h = min(int(page_h), max_height)
    driver.set_window_size(use_w, use_h)
    time.sleep(1.0)
    full_path = os.path.join(output_folder, filename)
    driver.save_screenshot(full_path)
    print(f"[capture_full_width] Salvo: {full_path} (window {use_w}x{use_h})")
    return full_path

def generate_market_overview_pdf(pages, pdf_name="Relatorio_Cripto_Mercado.pdf"):
    """
    pages: lista de tuples (url, filename)
    captura cada url em largura 4950 e junta em um √∫nico PDF
    """
    images = []
    for url, filename in pages:
        img = capture_full_width(url, filename, target_width=4950, max_height=12000)
        images.append(img)
    create_pdf_from_images(images, pdf_name)

# ----------------- Execu√ß√£o -----------------
if __name__ == "__main__":
    try:
        # Lista de s√≠mbolos (mantive a sua lista original)
        symbols = [
            ("ETH", "https://br.tradingview.com/symbols/ETHUSD/technicals/?exchange=BINANCE", "ETH - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf"),
            ("SOL", "https://br.tradingview.com/symbols/SOLUSD/technicals/?exchange=BINANCE", "SOL - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf"),
            ("LINK", "https://br.tradingview.com/symbols/LINKUSDT/technicals/?exchange=BINANCE", "LINK - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf"),
            ("KAS", "https://br.tradingview.com/symbols/KASUSD/technicals/?exchange=CRYPTO", "KAS - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf"),
            ("AAPL34", "https://br.tradingview.com/symbols/BMFBOVESPA-AAPL34/technicals/", "AAPL34 - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf"),
            ("MELI34", "https://br.tradingview.com/symbols/BMFBOVESPA-MELI34/technicals/", "MELI34 - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf"),
            ("BABA34", "https://br.tradingview.com/symbols/BMFBOVESPA-BABA34/technicals/", "BABA34 - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf")
        ]

        # Gera PDFs individuais para os s√≠mbolos
        generate_tradeview_symbol_pdfs(symbols)

        # Captura CoinMarketCap e TradingView World's Largest Companies em 4950px de largura
        overview_pages = [
            ("https://coinmarketcap.com/pt-br/", "CoinMarketCap_full_4950.png"),
            ("https://br.tradingview.com/markets/world-stocks/worlds-largest-companies/", "TradingView_Companies_full_4950.png")
        ]
        generate_market_overview_pdf(overview_pages, pdf_name="Relatorio_Cripto_Mercado.pdf")

    finally:
        driver.quit()
        print("Conclu√≠do. Driver encerrado.")
      </div>
      <p class="hint small">Clique no bloco acima para copiar todo o script Python.</p>
    </section>

  </div>

  <footer>
    <div class="small">Agora os links abrem em nova aba e o script Python est√° dispon√≠vel para copiar. üöÄ</div>
  </footer>
</div>

<div id="toast" class="toast">Copiado!</div>

<script>
  // guarda o script completo em uma vari√°vel pra uso no bot√£o
  const webScriptText = `import os
import time
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from fpdf import FPDF
from PIL import Image
from webdriver_manager.chrome import ChromeDriverManager

# --- Pasta de sa√≠da ---
output_folder = os.path.join(os.path.expanduser("~"), "Documents", "CriptoSonho")
os.makedirs(output_folder, exist_ok=True)

# --- Chrome options (gerenciador autom√°tico do chromedriver) ---
chrome_options = Options()
chrome_options.add_argument("--headless=new")
chrome_options.add_argument("--hide-scrollbars")
chrome_options.add_argument("--disable-gpu")
chrome_options.add_argument("--no-sandbox")
# N√£o definir window-size global aqui; vamos ajustar antes de cada captura

driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
wait = WebDriverWait(driver, 15)

# --- Helpers ---
def safe_click(xpath, timeout=10):
    try:
        el = WebDriverWait(driver, timeout).until(EC.presence_of_element_located((By.XPATH, xpath)))
        driver.execute_script("arguments[0].click();", el)
        time.sleep(1.2)
        return True
    except Exception as e:
        print(f"[safe_click] Falha ao clicar em {xpath}: {e}")
        return False

def save_screenshot_and_crop(full_path, out_path, width, height):
    \"\"\"Abre full_path, corta (0,0,width,height) e salva em out_path.\"\"\"
    img = Image.open(full_path)
    # Se imagem for menor que crop, ajusta para o tamanho dispon√≠vel
    img_w, img_h = img.size
    crop_w = min(width, img_w)
    crop_h = min(height, img_h)
    cropped = img.crop((0, 0, crop_w, crop_h))
    cropped.save(out_path)

# --- Parte A: PDFs individuais para s√≠mbolos (TradingView) ---
def capture_top_screenshot_for_timeframe(url, timeframe_xpath, filename, crop_width=1888, crop_height=2190):
    \"\"\"
    Acessa url, clica no timeframe indicado por timeframe_xpath (se fornecido),
    tira screenshot full page e corta top para crop_width x crop_height.
    \"\"\"
    driver.get(url)
    time.sleep(4)  # aguarda carregar a p√°gina e scripts
    # tenta clicar o timeframe (caso xpath exista)
    if timeframe_xpath:
        try:
            safe_click(timeframe_xpath, timeout=6)
        except Exception:
            pass

    # Ajusta janela para o tamanho total do documento antes de salvar
    scroll_w = driver.execute_script("return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, window.innerWidth);")
    scroll_h = driver.execute_script("return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, window.innerHeight);")
    # limitar height razoavelmente para evitar erros de plataforma; aqui permitimos at√© 10000
    scroll_h = min(scroll_h, 10000)
    driver.set_window_size(scroll_w, scroll_h)
    time.sleep(0.8)
    full_path = os.path.join(output_folder, "full_" + filename)
    driver.save_screenshot(full_path)
    out_path = os.path.join(output_folder, filename)
    save_screenshot_and_crop(full_path, out_path, crop_width, crop_height)
    print(f"[capture_top] Salvo: {out_path}")
    return out_path

def create_pdf_from_images(image_paths, pdf_name):
    pdf_path = os.path.join(output_folder, pdf_name)
    if os.path.exists(pdf_path):
        os.remove(pdf_path)
    pdf = FPDF(unit="pt", format="A4")
    page_w, page_h = pdf.w_pt, pdf.h_pt
    for img_path in image_paths:
        img = Image.open(img_path)
        img_w, img_h = img.size
        ratio = min(page_w / img_w, page_h / img_h)
        new_w, new_h = img_w * ratio, img_h * ratio
        x = (page_w - new_w) / 2
        y = (page_h - new_h) / 2
        pdf.add_page()
        pdf.image(img_path, x, y, new_w, new_h)
    pdf.output(pdf_path)
    print(f"[create_pdf] PDF gerado: {pdf_path}")
    return pdf_path

def generate_tradeview_symbol_pdfs(symbols):
    \"\"\"
    symbols: lista de tuplas (symbol, url, pdf_name)
    para cada s√≠mbolo gera 3 screenshots: 1D, 1W, 1M (usando xpaths de timeframe)
    \"\"\"
    # XPaths de timeframe (usados no seu script original)
    xpaths = {
        "1D": '//*[@id=\"1D\"]/span[1]/span',
        "1W": '//*[@id=\"1W\"]/span[1]/span',
        "1M": '//*[@id=\"1M\"]/span[1]/span'
    }

    for symbol, url, pdf_name in symbols:
        print(f\"\\n[Symbols] Processando {symbol} -> {url}\")
        shots = []
        # 1D
        shots.append(capture_top_screenshot_for_timeframe(url, xpaths[\"1D\"], f\"{symbol}_1D.png\", crop_width=1888, crop_height=2190))
        # 1W
        shots.append(capture_top_screenshot_for_timeframe(url, xpaths[\"1W\"], f\"{symbol}_1W.png\", crop_width=1888, crop_height=2190))
        # 1M
        shots.append(capture_top_screenshot_for_timeframe(url, xpaths[\"1M\"], f\"{symbol}_1M.png\", crop_width=1888, crop_height=2190))
        # cria PDF com 3 imagens
        create_pdf_from_images(shots, pdf_name)

# --- Parte B: Capturas full-width 4950px (CoinMarketCap + TradingView Companies) ---
def capture_full_width(url, filename, target_width=4950, max_height=12000):
    \"\"\"
    Captura a p√°gina inteira definindo a largura target_width e altura baseada no scrollHeight.
    Salva image em output_folder/filename e retorna caminho.
    \"\"\"
    driver.get(url)
    time.sleep(4)  # aguarda carregamento inicial
    
    # calcula scrollHeight e define janela
    page_w = driver.execute_script(\"return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, window.innerWidth);\")
    page_h = driver.execute_script(\"return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, window.innerHeight);\")
    # queremos for√ßar largura = target_width, e altura = page_h (limitada)
    use_w = max(target_width, page_w)
    use_h = min(int(page_h), max_height)
    driver.set_window_size(use_w, use_h)
    time.sleep(1.0)
    full_path = os.path.join(output_folder, filename)
    driver.save_screenshot(full_path)
    print(f\"[capture_full_width] Salvo: {full_path} (window {use_w}x{use_h})\")
    return full_path

def generate_market_overview_pdf(pages, pdf_name=\"Relatorio_Cripto_Mercado.pdf\"):
    \"\"\"
    pages: lista de tuples (url, filename)
    captura cada url em largura 4950 e junta em um √∫nico PDF
    \"\"\"
    images = []
    for url, filename in pages:
        img = capture_full_width(url, filename, target_width=4950, max_height=12000)
        images.append(img)
    create_pdf_from_images(images, pdf_name)

# ----------------- Execu√ß√£o -----------------
if __name__ == \"__main__\":
    try:
        # Lista de s√≠mbolos (mantive a sua lista original)
        symbols = [
            (\"ETH\", \"https://br.tradingview.com/symbols/ETHUSD/technicals/?exchange=BINANCE\", \"ETH - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\"),
            (\"SOL\", \"https://br.tradingview.com/symbols/SOLUSD/technicals/?exchange=BINANCE\", \"SOL - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\"),
            (\"LINK\", \"https://br.tradingview.com/symbols/LINKUSDT/technicals/?exchange=BINANCE\", \"LINK - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\"),
            (\"KAS\", \"https://br.tradingview.com/symbols/KASUSD/technicals/?exchange=CRYPTO\", \"KAS - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\"),
            (\"AAPL34\", \"https://br.tradingview.com/symbols/BMFBOVESPA-AAPL34/technicals/\", \"AAPL34 - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\"),
            (\"MELI34\", \"https://br.tradingview.com/symbols/BMFBOVESPA-MELI34/technicals/\", \"MELI34 - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\"),
            (\"BABA34\", \"https://br.tradingview.com/symbols/BMFBOVESPA-BABA34/technicals/\", \"BABA34 - Sinais T√©cnicos (1 Dia, 1 Semana, 1 M√™s).pdf\")
        ]

        # Gera PDFs individuais para os s√≠mbolos
        generate_tradeview_symbol_pdfs(symbols)

        # Captura CoinMarketCap e TradingView World's Largest Companies em 4950px de largura
        overview_pages = [
            (\"https://coinmarketcap.com/pt-br/\", \"CoinMarketCap_full_4950.png\"),
            (\"https://br.tradingview.com/markets/world-stocks/worlds-largest-companies/\", \"TradingView_Companies_full_4950.png\")
        ]
        generate_market_overview_pdf(overview_pages, pdf_name=\"Relatorio_Cripto_Mercado.pdf\")

    finally:
        driver.quit()
        print(\"Conclu√≠do. Driver encerrado.\")
`;

  function copyText(ev, text) {
    if (ev) ev.stopPropagation();
    _copyString(text);
  }

  // copiar ao clicar nos blocos
  document.querySelectorAll('[data-copy]').forEach(el=>{
    el.addEventListener('click', ()=>_copyString(el.innerText.trim()));
  });

  document.getElementById('copyAll').addEventListener('click', function(){
    const parts = [];
    document.querySelectorAll('.url').forEach(u => parts.push(u.innerText.trim()));
    document.querySelectorAll('.text-block').forEach(tb => parts.push('\n---\n', tb.innerText.trim()));
    _copyString(parts.join('\n'));
  });

  function _copyString(text){
    if(!text) return _showToast('Nada pra copiar');
    if(navigator.clipboard && navigator.clipboard.writeText){
      navigator.clipboard.writeText(text).then(()=>_showToast('Copiado!'), ()=>_fallbackCopy(text));
    } else {
      _fallbackCopy(text);
    }
  }

  function _fallbackCopy(text){
    try {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      document.body.removeChild(ta);
      _showToast(ok ? 'Copiado!' : 'Falha ao copiar');
    } catch (e){
      _showToast('Falha ao copiar');
    }
  }

  function _showToast(msg){
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('show');
    setTimeout(()=>t.classList.remove('show'), 1600);
  }
</script>
</body>
</html>
